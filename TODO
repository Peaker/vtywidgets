* Scroll:
  * A scrollable display can also just have the size it was
    given. Bounding Rect is probably not what I want to use:
    Just use the srMaxSize of the scrollable.

  * I want to decide whether to make hbar/vbar based on the size I was
    given, but Grid wants them to make its SizeRange.

  * A scrollable display may only have an estimate about the scroll
    range in each axis, rather than an actual size, so the interface
    should be something like:

    type RangeRatio = (Double, Double)
    scrollEstimate :: SizeRange -> ((RangeRatio, RangeRatio), Display a) -> Display a

* PotentialScroller:
  * Choose a Scroller or the widget, based on whether or not it fits
    in the given space...

* FocusDelegator:
  * Need to replace def_attr with that which keeps the external attr

* Widget can also have an "entry" function that returns the same "k"
  that lets it move to where it was entered from?
  * Maybe replace Keymap with Eventmap and replace ModKey with
    EventKey, and have other possible events?
  * Then "direction-entry/direction-exit" could be another event the
    widget is allowed to handle
  * Then mouse events could be sent too...

* Currently, I'd need to heuristic diff on TextEdit changes to know
  what it changed... Maybe create a composable Diff that can describe
  changes accurately?

* makeWidget should Clip the subwidget images:

  Image.clip :: Monoid a => IntersectRect -> Endo (Image a)

  mempty for any out-of-intersection position, to not break the
  guarantee that nothing is outside the clip rect of the image

* Grid

  * Instead of Grid neutralizing non-current children -- they should
    do so themselves, based on HasFocus

    * This way, all widgets can implement "global" bindings that do
      whatever they want

    * No ugly clearing of the keymap and image cursor of grid children

* Trace entries: How to do IO to read the entries?
  * Can have the keymap export the IO action to generate the model
